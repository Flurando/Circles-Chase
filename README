This is a learning project as I am not only new to game dev but also new to coding world.
So don't expect any eyestunning scenario or exciting game play experience.
However, any suggestion or criticism is welcomed -- better if you could tell me how by the way requesting what to implement, but not required.
The stuff I am working on and the future improvements are listed in TODO.org, which you should be able to see easily in the root directory.
While the code is intended to be run with guile and chickadee, launching it is as easy as running "chickadee play main.w --language=wisp" in the root directory.
As you may notice, all the includes in main.w ends in .scm and everything out of main.w seems to abandon the wisp syntax. This is because loading and including seems to need kind of reader, and the reader is still schemy -- Well, I admit that I don't understand how everything goes under the hook, but the resault is I have to load scheme instead of wisp.
There might be some occasions that you would encounter two files, exactly the same, ending in .w and .scm respectively. That .scm file is the result of running a program called "wisp2lisp". For other files with only .scm, they are written originally with parens. Just don't get confused.
By the way, there are some dependencies that you need to be able to run this: guile-3.0.9, guile-chickadee-0.10.0 and guile-wisp-1.0.12
You might use different versions, as these are just what I have on my machine, not the must-meets.
Note that these three packages may depend on other packages as well, like guile-sdl2 and so on. I used GNU Guix package manager to install them, and you have other choices obviously.
The project is layed out in modular manner(At least, in my point of view) because I find that even drawing some static words on the screen can be hard to read and maintain if they all live in main.w
So I used the tactic of including and loading since these are the simplist I can handle. I know there is libraries, there is modules, and so on, but those are hard and require me to write my own run-game procedure instead of envoking "chickadee play" directly.
You may wonder why I don't just use the template from the author of chickadee. That is because I tried, for a whole morning, but still can't pass the autoconf and make stuff, with a stubborn error of saying GUILE([3.0]) is invalid syntax. I give up at last, sadly.
The hardest part I have realized about 2D game developing is that I have to implement (actually is mimicing, because I obviously can't write out codes of that high level from fulks spent more than 10 years in game development) many common things in nowaday games with huge effort. I have to consider how to iterate, what data type to use, how to arrange my code where something defined here should be used in a random file else where! These are great obstacles, I think.
Why can't I consider, like, let monster do this, go there, disappear when defeated, or enter another scene solely? Instead of thinking, like, use this 2D vector to represent the position of a monster, shall I use channels or other stuff to send and receive state changes, recalculate the vector, detecting if the key is pressed and do something then, how to clean up and tell the engine don't calculate the vectors and don't draw anymore when I wish to switch a scene?
I wanna say "Game Dev" is broken, in a way that before becoming a game developer, one must become a junior coder, at least with the knowledge of how to implement and arrange those stuff like a junior coder, rather than being able to make nice terminal game as long as one is able to type and good at making an adventure story, with the power of some nice drawing experience one can step further into the world of 2D or even 3D gaming. Tragic.
Anyway, at last, I guess I have to be familiar with the implementations of at least the popular stuff like UI and so on if I want to make game developing easier for non-coders. That is the reason I start this learning project, for myself, preparing.
Though the code base is tiny now, I still think I should maintain a STRUCTURE file listing out what each file does and where there is cross-file calls or usage of variable defined in other files. Because there is ALREADY a lot and it is harder and harder for me to remember whether an unused procedure is used somewhere important.
